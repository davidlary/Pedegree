#!/usr/bin/env python3
"""
AutoUpdateSystem.py - Automatic Model Detection and Local LLM Installation

Features:
- Detects new models from API endpoints (gpt-5, claude-4, grok-5, etc.)
- Auto-installs new local LLMs via Ollama
- Maintains model database with version tracking
- Schedules periodic updates
- Sends notifications about new models

Generated by GetAvailableModels.py for automatic maintenance
"""

import os
import json
import subprocess
import requests
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Set
from concurrent.futures import ThreadPoolExecutor
import schedule


class AutoUpdateSystem:
    def __init__(self, models_data_file: str = 'available_models.json'):
        """Initialize auto-update system."""
        self.models_data_file = models_data_file
        self.update_log_file = 'model_update_log.json'
        self.config_file = 'auto_update_config.json'
        
        # Load existing data
        self.current_models = self._load_current_models()
        self.update_history = self._load_update_history()
        self.config = self._load_config()
        
        # API configurations
        self.api_configs = {
            'openai': {
                'endpoint': 'https://api.openai.com/v1/models',
                'headers': {'Authorization': f'Bearer {os.getenv("OPENAI_API_KEY")}'},
                'model_patterns': ['gpt-', 'o1-', 'chatgpt-']
            },
            'anthropic': {
                'endpoint': None,  # Anthropic doesn't expose model list API
                'expected_models': ['claude-4', 'claude-3.5', 'claude-5'],
                'pricing_api': 'https://pricing.anthropic.com/api/models'
            },
            'xai': {
                'endpoint': 'https://api.x.ai/v1/models',
                'headers': {'Authorization': f'Bearer {os.getenv("XAI_API_KEY")}'},
                'model_patterns': ['grok-']
            },
            'google': {
                'endpoint': 'https://generativelanguage.googleapis.com/v1/models',
                'headers': {'Authorization': f'Bearer {os.getenv("GOOGLE_API_KEY")}'},
                'model_patterns': ['gemini-']
            }
        }
        
        # Ollama model recommendations for auto-installation (Latest 2025 models)
        self.recommended_local_models = [
            # Latest flagship models
            'llama3.3:70b', 'deepseek-r1:8b', 'deepseek-r1:7b',
            'qwen3:8b', 'qwen3:14b', 'qwen3:32b', 'qwen3:1.7b',
            
            # Latest coding specialists
            'qwen2.5-coder:7b', 'qwen2.5-coder:14b', 'qwen2.5-coder:32b',
            
            # Vision models
            'qwen2.5vl:7b', 'qwen2.5vl:32b', 'llava:13b',
            
            # Reasoning specialists
            'qwq:32b',
            
            # Latest general models
            'llama3.1:8b', 'llama3.1:70b', 'gemma3:9b', 'gemma3:4b',
            'phi4:14b', 'mistral-nemo:12b',
            
            # Proven reliable models
            'mistral:7b', 'mixtral:8x7b'
        ]

    def _load_current_models(self) -> Dict[str, Any]:
        """Load current model database."""
        try:
            with open(self.models_data_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {'providers': {}, 'local_models': {}, 'last_updated': None}

    def _load_update_history(self) -> List[Dict]:
        """Load update history log."""
        try:
            with open(self.update_log_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return []

    def _load_config(self) -> Dict[str, Any]:
        """Load auto-update configuration."""
        default_config = {
            'auto_update_enabled': True,
            'check_interval_hours': 24,
            'auto_install_local_models': True,
            'max_local_models': 10,
            'preferred_model_sizes': ['1.7b', '4b', '7b', '8b', '9b', '12b', '14b'],  # Optimized for Apple Silicon 2025
            'exclude_patterns': ['*:latest'],  # Avoid installing 'latest' tags
            'notification_email': None,
            'last_check': None
        }
        
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                # Merge with defaults for any missing keys
                for key, value in default_config.items():
                    if key not in config:
                        config[key] = value
                return config
        except FileNotFoundError:
            return default_config

    def _save_config(self):
        """Save configuration to file."""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)

    def _save_update_history(self):
        """Save update history to file."""
        with open(self.update_log_file, 'w') as f:
            json.dump(self.update_history, f, indent=2)

    def check_for_new_models(self) -> Dict[str, List[str]]:
        """Dynamically check all providers for new models."""
        print("🔍 Checking for new models across all providers...")
        new_models = {'hosted': [], 'local': []}
        
        # Use the dynamic discovery system
        try:
            from GetAvailableModels import EnhancedModelInfoCollector
            collector = EnhancedModelInfoCollector()
            
            print("🔍 Running dynamic model discovery...")
            discovered = collector.discover_available_models()
            
            # Compare with existing models to find new ones
            current_models = self.current_models.get('providers', {})
            current_local = self.current_models.get('local_models', {})
            
            # Check for new hosted models
            for provider, models in discovered.items():
                if provider == 'ollama':
                    continue  # Handle local separately
                    
                current_provider_models = set(current_models.get(provider, {}).keys())
                discovered_model_ids = {m.get('id', m.get('name')) for m in models}
                
                new_in_provider = discovered_model_ids - current_provider_models
                for model_id in new_in_provider:
                    if model_id:
                        new_models['hosted'].append(f"{provider}:{model_id}")
                        print(f"🆕 New hosted model: {provider}:{model_id}")
            
            # Check for new local models
            if 'ollama' in discovered:
                current_local_models = set(current_local.keys())
                discovered_local = {collector._convert_ollama_name_to_id(m.get('name', '')) 
                                  for m in discovered['ollama'] if m.get('name')}
                
                new_local = discovered_local - current_local_models
                for model_id in new_local:
                    if model_id:
                        new_models['local'].append(model_id)
                        print(f"🆕 New local model available: {model_id}")
                        
        except Exception as e:
            print(f"❌ Error in dynamic discovery: {e}")
            # Fallback to manual checking
            return self._manual_model_check()
        
        # Log the check
        self.config['last_check'] = datetime.now().isoformat()
        self._save_config()
        
        print(f"✅ Discovery complete: {len(new_models['hosted'])} new hosted, {len(new_models['local'])} new local")
        return new_models

    def _manual_model_check(self) -> Dict[str, List[str]]:
        """Fallback manual model checking."""
        print("🔄 Falling back to manual model checking...")
        new_models = {'hosted': [], 'local': []}
        
        # Check hosted models manually
        for provider, config in self.api_configs.items():
            try:
                provider_new_models = self._check_provider_models(provider, config)
                new_models['hosted'].extend(provider_new_models)
            except Exception as e:
                print(f"⚠️  Failed to check {provider}: {e}")
        
        # Check for new local models in Ollama registry
        try:
            local_new_models = self._check_ollama_registry()
            new_models['local'].extend(local_new_models)
        except Exception as e:
            print(f"⚠️  Failed to check Ollama registry: {e}")
        
        return new_models

    def _check_provider_models(self, provider: str, config: Dict) -> List[str]:
        """Check a specific provider for new models."""
        if not config.get('endpoint'):
            return []
        
        try:
            headers = config.get('headers', {})
            response = requests.get(config['endpoint'], headers=headers, timeout=30)
            
            if response.status_code != 200:
                print(f"⚠️  {provider} API returned {response.status_code}")
                return []
            
            api_models = response.json().get('data', [])
            current_provider_models = self.current_models.get('providers', {}).get(provider, {})
            
            new_models = []
            patterns = config.get('model_patterns', [])
            
            for model in api_models:
                model_id = model.get('id', '')
                
                # Check if model matches expected patterns
                if any(pattern in model_id for pattern in patterns):
                    if model_id not in current_provider_models:
                        new_models.append(f"{provider}/{model_id}")
                        print(f"🆕 New model detected: {provider}/{model_id}")
            
            return new_models
            
        except Exception as e:
            print(f"❌ Error checking {provider}: {e}")
            return []

    def _check_ollama_registry(self) -> List[str]:
        """Check Ollama registry for new models."""
        try:
            # Get currently installed models
            result = subprocess.run(['ollama', 'list'], capture_output=True, text=True)
            if result.returncode != 0:
                return []
            
            installed_models = set()
            for line in result.stdout.strip().split('\n')[1:]:  # Skip header
                if line.strip():
                    model_name = line.split()[0]
                    installed_models.add(model_name)
            
            # Check recommended models that aren't installed
            new_models = []
            for model in self.recommended_local_models:
                if model not in installed_models:
                    # Check if model exists in registry
                    check_result = subprocess.run(
                        ['ollama', 'show', model], 
                        capture_output=True, text=True
                    )
                    if check_result.returncode == 0:
                        new_models.append(model)
                        print(f"🆕 New local model available: {model}")
            
            return new_models
            
        except Exception as e:
            print(f"❌ Error checking Ollama registry: {e}")
            return []

    def auto_install_local_models(self, new_models: List[str]) -> Dict[str, bool]:
        """Automatically install new local models via Ollama."""
        if not self.config.get('auto_install_local_models', False):
            print("🔒 Auto-installation disabled in config")
            return {}
        
        print(f"🤖 Auto-installing {len(new_models)} new local models...")
        installation_results = {}
        
        # Check available disk space
        if not self._check_disk_space():
            print("⚠️  Insufficient disk space for model installation")
            return {}
        
        # Check current model count using dynamic discovery
        try:
            from GetAvailableModels import EnhancedModelInfoCollector
            collector = EnhancedModelInfoCollector()
            discovered = collector._discover_ollama_models()
            current_count = len([m for m in discovered if m.get('status') == 'installed'])
        except:
            current_count = len(self.current_models.get('local_models', {}))
        
        max_models = self.config.get('max_local_models', 10)
        
        if current_count >= max_models:
            print(f"🚫 Maximum local models ({max_models}) already installed")
            return {}
        
        # Filter models by size preference
        filtered_models = self._filter_models_by_size(new_models)
        
        for model in filtered_models[:max_models - current_count]:
            try:
                print(f"📥 Installing {model}...")
                start_time = time.time()
                
                result = subprocess.run(
                    ['ollama', 'pull', model], 
                    capture_output=True, text=True, timeout=1800  # 30 minute timeout
                )
                
                install_time = time.time() - start_time
                
                if result.returncode == 0:
                    installation_results[model] = True
                    print(f"✅ {model} installed successfully ({install_time:.1f}s)")
                    
                    # Log installation
                    self.update_history.append({
                        'timestamp': datetime.now().isoformat(),
                        'action': 'install_local_model',
                        'model': model,
                        'success': True,
                        'install_time_seconds': install_time
                    })
                    
                else:
                    installation_results[model] = False
                    print(f"❌ Failed to install {model}: {result.stderr}")
                    
                    # Log failure
                    self.update_history.append({
                        'timestamp': datetime.now().isoformat(),
                        'action': 'install_local_model',
                        'model': model,
                        'success': False,
                        'error': result.stderr
                    })
                    
            except subprocess.TimeoutExpired:
                installation_results[model] = False
                print(f"⏰ Installation of {model} timed out")
            except Exception as e:
                installation_results[model] = False
                print(f"❌ Error installing {model}: {e}")
        
        self._save_update_history()
        return installation_results

    def _check_disk_space(self, required_gb: int = 10) -> bool:
        """Check if there's enough disk space for model installation."""
        try:
            result = subprocess.run(['df', '-h', '.'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) > 1:
                    space_info = lines[1].split()
                    available = space_info[3]  # Available space column
                    # Parse available space (could be in GB, TB, etc.)
                    if 'G' in available:
                        available_gb = float(available.replace('G', ''))
                        return available_gb >= required_gb
            return True  # Default to allowing if we can't determine
        except:
            return True

    def _filter_models_by_size(self, models: List[str]) -> List[str]:
        """Filter models by preferred sizes for Apple Silicon."""
        preferred_sizes = self.config.get('preferred_model_sizes', ['7b', '8b', '13b'])
        exclude_patterns = self.config.get('exclude_patterns', [])
        
        filtered = []
        for model in models:
            # Check exclude patterns
            if any(pattern.replace('*', '') in model for pattern in exclude_patterns):
                continue
            
            # Prefer models with preferred sizes
            if any(size in model for size in preferred_sizes):
                filtered.append(model)
        
        # If no preferred size models, include smaller models
        if not filtered:
            for model in models:
                if any(size in model.lower() for size in ['mini', '1b', '3b', '6b', '7b']):
                    filtered.append(model)
        
        return filtered

    def update_model_database(self):
        """Update the model database with new discoveries."""
        print("💾 Updating model database...")
        
        # Re-run the main collector to get latest data
        try:
            from GetAvailableModels import EnhancedModelInfoCollector
            collector = EnhancedModelInfoCollector()
            
            if collector.collect_all_models():
                collector.save_json()
                collector.save_html_table()  # This will auto-open
                print("✅ Model database updated successfully")
                
                # Log the update
                self.update_history.append({
                    'timestamp': datetime.now().isoformat(),
                    'action': 'update_database',
                    'success': True
                })
                self._save_update_history()
                return True
            else:
                print("❌ Failed to update model database")
                return False
                
        except Exception as e:
            print(f"❌ Error updating database: {e}")
            return False

    def run_update_cycle(self):
        """Run a complete update cycle."""
        print("🚀 Starting automatic update cycle...")
        print("=" * 60)
        
        # Check for new models
        new_models = self.check_for_new_models()
        
        total_new = len(new_models['hosted']) + len(new_models['local'])
        if total_new == 0:
            print("✅ No new models detected")
            return
        
        print(f"🆕 Found {total_new} new models:")
        for model in new_models['hosted']:
            print(f"  📡 {model}")
        for model in new_models['local']:
            print(f"  💻 {model}")
        
        # Auto-install local models
        if new_models['local']:
            installation_results = self.auto_install_local_models(new_models['local'])
            successful_installs = sum(1 for success in installation_results.values() if success)
            print(f"✅ Successfully installed {successful_installs}/{len(new_models['local'])} local models")
        
        # Update database
        if total_new > 0:
            self.update_model_database()
        
        print("🎉 Update cycle completed!")

    def setup_scheduler(self):
        """Setup automatic scheduled updates."""
        if not self.config.get('auto_update_enabled', True):
            print("🔒 Automatic updates disabled in config")
            return
        
        interval_hours = self.config.get('check_interval_hours', 24)
        
        # Schedule the update job
        schedule.every(interval_hours).hours.do(self.run_update_cycle)
        
        print(f"⏰ Scheduled automatic updates every {interval_hours} hours")
        print("🔄 Starting scheduler... (Press Ctrl+C to stop)")
        
        try:
            while True:
                schedule.run_pending()
                time.sleep(3600)  # Check every hour
        except KeyboardInterrupt:
            print("\n🛑 Scheduler stopped")

    def get_update_status(self) -> Dict[str, Any]:
        """Get current update system status."""
        last_check = self.config.get('last_check')
        recent_updates = [
            update for update in self.update_history
            if datetime.fromisoformat(update['timestamp']) > datetime.now() - timedelta(days=7)
        ]
        
        return {
            'auto_update_enabled': self.config.get('auto_update_enabled', True),
            'last_check': last_check,
            'next_check_due': self._calculate_next_check(),
            'recent_updates': len(recent_updates),
            'local_models_installed': len(self.current_models.get('local_models', {})),
            'max_local_models': self.config.get('max_local_models', 10),
            'disk_space_ok': self._check_disk_space()
        }

    def _calculate_next_check(self) -> Optional[str]:
        """Calculate when the next check is due."""
        last_check = self.config.get('last_check')
        if not last_check:
            return "Now (never checked)"
        
        last_check_time = datetime.fromisoformat(last_check)
        interval_hours = self.config.get('check_interval_hours', 24)
        next_check = last_check_time + timedelta(hours=interval_hours)
        
        if next_check <= datetime.now():
            return "Now (overdue)"
        else:
            return next_check.isoformat()

    def force_update_check(self):
        """Force an immediate update check."""
        print("🔄 Forcing immediate update check...")
        self.run_update_cycle()

    def configure_settings(self, **kwargs):
        """Update configuration settings."""
        print("⚙️  Updating configuration...")
        
        for key, value in kwargs.items():
            if key in self.config:
                old_value = self.config[key]
                self.config[key] = value
                print(f"  {key}: {old_value} → {value}")
            else:
                print(f"  Unknown setting: {key}")
        
        self._save_config()
        print("✅ Configuration updated")


def main():
    """Main execution function."""
    updater = AutoUpdateSystem()
    
    import sys
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == 'check':
            updater.force_update_check()
        elif command == 'schedule':
            updater.setup_scheduler()
        elif command == 'status':
            status = updater.get_update_status()
            print("\n📊 Auto-Update System Status")
            print("=" * 40)
            for key, value in status.items():
                print(f"{key}: {value}")
        elif command == 'config':
            if len(sys.argv) > 3:
                setting = sys.argv[2]
                value = sys.argv[3]
                # Convert string values to appropriate types
                if value.lower() in ['true', 'false']:
                    value = value.lower() == 'true'
                elif value.isdigit():
                    value = int(value)
                updater.configure_settings(**{setting: value})
            else:
                print("Usage: python AutoUpdateSystem.py config <setting> <value>")
        else:
            print("Available commands: check, schedule, status, config")
    else:
        # Default: run update cycle
        updater.run_update_cycle()


if __name__ == "__main__":
    main()